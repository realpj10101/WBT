{
  "version": 3,
  "sources": ["../../../../../../../src/cdk/text-field/autofill.ts", "../../../../../../../src/cdk/text-field/autosize.ts", "../../../../../../../src/cdk/text-field/text-field-module.ts", "../../../../../../../src/cdk/text-field/text-field_public_index.ts", "../../../../../../../src/material/input/input-errors.ts", "../../../../../../../src/material/input/input-value-accessor.ts", "../../../../../../../src/material/input/input.ts", "../../../../../../../src/material/input/module.ts", "../../../../../../../src/material/input/input_public_index.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Platform, normalizePassiveListenerOptions} from '@angular/cdk/platform';\nimport {\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Injectable,\n  NgZone,\n  OnDestroy,\n  OnInit,\n  Output,\n} from '@angular/core';\nimport {coerceElement} from '@angular/cdk/coercion';\nimport {EMPTY, Observable, Subject} from 'rxjs';\n\n/** An event that is emitted when the autofill state of an input changes. */\nexport type AutofillEvent = {\n  /** The element whose autofill state changes. */\n  target: Element;\n  /** Whether the element is currently autofilled. */\n  isAutofilled: boolean;\n};\n\n/** Used to track info about currently monitored elements. */\ntype MonitoredElementInfo = {\n  readonly subject: Subject<AutofillEvent>;\n  unlisten: () => void;\n};\n\n/** Options to pass to the animationstart listener. */\nconst listenerOptions = normalizePassiveListenerOptions({passive: true});\n\n/**\n * An injectable service that can be used to monitor the autofill state of an input.\n * Based on the following blog post:\n * https://medium.com/@brunn/detecting-autofilled-fields-in-javascript-aed598d25da7\n */\n@Injectable({providedIn: 'root'})\nexport class AutofillMonitor implements OnDestroy {\n  private _monitoredElements = new Map<Element, MonitoredElementInfo>();\n\n  constructor(private _platform: Platform, private _ngZone: NgZone) {}\n\n  /**\n   * Monitor for changes in the autofill state of the given input element.\n   * @param element The element to monitor.\n   * @return A stream of autofill state changes.\n   */\n  monitor(element: Element): Observable<AutofillEvent>;\n\n  /**\n   * Monitor for changes in the autofill state of the given input element.\n   * @param element The element to monitor.\n   * @return A stream of autofill state changes.\n   */\n  monitor(element: ElementRef<Element>): Observable<AutofillEvent>;\n\n  monitor(elementOrRef: Element | ElementRef<Element>): Observable<AutofillEvent> {\n    if (!this._platform.isBrowser) {\n      return EMPTY;\n    }\n\n    const element = coerceElement(elementOrRef);\n    const info = this._monitoredElements.get(element);\n\n    if (info) {\n      return info.subject;\n    }\n\n    const result = new Subject<AutofillEvent>();\n    const cssClass = 'cdk-text-field-autofilled';\n    const listener = ((event: AnimationEvent) => {\n      // Animation events fire on initial element render, we check for the presence of the autofill\n      // CSS class to make sure this is a real change in state, not just the initial render before\n      // we fire off events.\n      if (\n        event.animationName === 'cdk-text-field-autofill-start' &&\n        !element.classList.contains(cssClass)\n      ) {\n        element.classList.add(cssClass);\n        this._ngZone.run(() => result.next({target: event.target as Element, isAutofilled: true}));\n      } else if (\n        event.animationName === 'cdk-text-field-autofill-end' &&\n        element.classList.contains(cssClass)\n      ) {\n        element.classList.remove(cssClass);\n        this._ngZone.run(() => result.next({target: event.target as Element, isAutofilled: false}));\n      }\n    }) as EventListenerOrEventListenerObject;\n\n    this._ngZone.runOutsideAngular(() => {\n      element.addEventListener('animationstart', listener, listenerOptions);\n      element.classList.add('cdk-text-field-autofill-monitored');\n    });\n\n    this._monitoredElements.set(element, {\n      subject: result,\n      unlisten: () => {\n        element.removeEventListener('animationstart', listener, listenerOptions);\n      },\n    });\n\n    return result;\n  }\n\n  /**\n   * Stop monitoring the autofill state of the given input element.\n   * @param element The element to stop monitoring.\n   */\n  stopMonitoring(element: Element): void;\n\n  /**\n   * Stop monitoring the autofill state of the given input element.\n   * @param element The element to stop monitoring.\n   */\n  stopMonitoring(element: ElementRef<Element>): void;\n\n  stopMonitoring(elementOrRef: Element | ElementRef<Element>): void {\n    const element = coerceElement(elementOrRef);\n    const info = this._monitoredElements.get(element);\n\n    if (info) {\n      info.unlisten();\n      info.subject.complete();\n      element.classList.remove('cdk-text-field-autofill-monitored');\n      element.classList.remove('cdk-text-field-autofilled');\n      this._monitoredElements.delete(element);\n    }\n  }\n\n  ngOnDestroy() {\n    this._monitoredElements.forEach((_info, element) => this.stopMonitoring(element));\n  }\n}\n\n/** A directive that can be used to monitor the autofill state of an input. */\n@Directive({\n  selector: '[cdkAutofill]',\n})\nexport class CdkAutofill implements OnDestroy, OnInit {\n  /** Emits when the autofill state of the element changes. */\n  @Output() readonly cdkAutofill = new EventEmitter<AutofillEvent>();\n\n  constructor(\n    private _elementRef: ElementRef<HTMLElement>,\n    private _autofillMonitor: AutofillMonitor,\n  ) {}\n\n  ngOnInit() {\n    this._autofillMonitor\n      .monitor(this._elementRef)\n      .subscribe(event => this.cdkAutofill.emit(event));\n  }\n\n  ngOnDestroy() {\n    this._autofillMonitor.stopMonitoring(this._elementRef);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NumberInput, coerceNumberProperty} from '@angular/cdk/coercion';\nimport {\n  Directive,\n  ElementRef,\n  Input,\n  AfterViewInit,\n  DoCheck,\n  OnDestroy,\n  NgZone,\n  Optional,\n  Inject,\n  booleanAttribute,\n} from '@angular/core';\nimport {Platform} from '@angular/cdk/platform';\nimport {auditTime, takeUntil} from 'rxjs/operators';\nimport {fromEvent, Subject} from 'rxjs';\nimport {DOCUMENT} from '@angular/common';\n\n/** Directive to automatically resize a textarea to fit its content. */\n@Directive({\n  selector: 'textarea[cdkTextareaAutosize]',\n  exportAs: 'cdkTextareaAutosize',\n  host: {\n    'class': 'cdk-textarea-autosize',\n    // Textarea elements that have the directive applied should have a single row by default.\n    // Browsers normally show two rows by default and therefore this limits the minRows binding.\n    'rows': '1',\n    '(input)': '_noopInputHandler()',\n  },\n})\nexport class CdkTextareaAutosize implements AfterViewInit, DoCheck, OnDestroy {\n  /** Keep track of the previous textarea value to avoid resizing when the value hasn't changed. */\n  private _previousValue?: string;\n  private _initialHeight: string | undefined;\n  private readonly _destroyed = new Subject<void>();\n\n  private _minRows: number;\n  private _maxRows: number;\n  private _enabled: boolean = true;\n\n  /**\n   * Value of minRows as of last resize. If the minRows has decreased, the\n   * height of the textarea needs to be recomputed to reflect the new minimum. The maxHeight\n   * does not have the same problem because it does not affect the textarea's scrollHeight.\n   */\n  private _previousMinRows: number = -1;\n\n  private _textareaElement: HTMLTextAreaElement;\n\n  /** Minimum amount of rows in the textarea. */\n  @Input('cdkAutosizeMinRows')\n  get minRows(): number {\n    return this._minRows;\n  }\n  set minRows(value: NumberInput) {\n    this._minRows = coerceNumberProperty(value);\n    this._setMinHeight();\n  }\n\n  /** Maximum amount of rows in the textarea. */\n  @Input('cdkAutosizeMaxRows')\n  get maxRows(): number {\n    return this._maxRows;\n  }\n  set maxRows(value: NumberInput) {\n    this._maxRows = coerceNumberProperty(value);\n    this._setMaxHeight();\n  }\n\n  /** Whether autosizing is enabled or not */\n  @Input({alias: 'cdkTextareaAutosize', transform: booleanAttribute})\n  get enabled(): boolean {\n    return this._enabled;\n  }\n  set enabled(value: boolean) {\n    // Only act if the actual value changed. This specifically helps to not run\n    // resizeToFitContent too early (i.e. before ngAfterViewInit)\n    if (this._enabled !== value) {\n      (this._enabled = value) ? this.resizeToFitContent(true) : this.reset();\n    }\n  }\n\n  @Input()\n  get placeholder(): string {\n    return this._textareaElement.placeholder;\n  }\n  set placeholder(value: string) {\n    this._cachedPlaceholderHeight = undefined;\n\n    if (value) {\n      this._textareaElement.setAttribute('placeholder', value);\n    } else {\n      this._textareaElement.removeAttribute('placeholder');\n    }\n\n    this._cacheTextareaPlaceholderHeight();\n  }\n\n  /** Cached height of a textarea with a single row. */\n  private _cachedLineHeight: number;\n  /** Cached height of a textarea with only the placeholder. */\n  private _cachedPlaceholderHeight?: number;\n\n  /** Used to reference correct document/window */\n  protected _document?: Document;\n\n  private _hasFocus: boolean;\n\n  private _isViewInited = false;\n\n  constructor(\n    private _elementRef: ElementRef<HTMLElement>,\n    private _platform: Platform,\n    private _ngZone: NgZone,\n    /** @breaking-change 11.0.0 make document required */\n    @Optional() @Inject(DOCUMENT) document?: any,\n  ) {\n    this._document = document;\n\n    this._textareaElement = this._elementRef.nativeElement as HTMLTextAreaElement;\n  }\n\n  /** Sets the minimum height of the textarea as determined by minRows. */\n  _setMinHeight(): void {\n    const minHeight =\n      this.minRows && this._cachedLineHeight ? `${this.minRows * this._cachedLineHeight}px` : null;\n\n    if (minHeight) {\n      this._textareaElement.style.minHeight = minHeight;\n    }\n  }\n\n  /** Sets the maximum height of the textarea as determined by maxRows. */\n  _setMaxHeight(): void {\n    const maxHeight =\n      this.maxRows && this._cachedLineHeight ? `${this.maxRows * this._cachedLineHeight}px` : null;\n\n    if (maxHeight) {\n      this._textareaElement.style.maxHeight = maxHeight;\n    }\n  }\n\n  ngAfterViewInit() {\n    if (this._platform.isBrowser) {\n      // Remember the height which we started with in case autosizing is disabled\n      this._initialHeight = this._textareaElement.style.height;\n      this.resizeToFitContent();\n\n      this._ngZone.runOutsideAngular(() => {\n        const window = this._getWindow();\n\n        fromEvent(window, 'resize')\n          .pipe(auditTime(16), takeUntil(this._destroyed))\n          .subscribe(() => this.resizeToFitContent(true));\n\n        this._textareaElement.addEventListener('focus', this._handleFocusEvent);\n        this._textareaElement.addEventListener('blur', this._handleFocusEvent);\n      });\n\n      this._isViewInited = true;\n      this.resizeToFitContent(true);\n    }\n  }\n\n  ngOnDestroy() {\n    this._textareaElement.removeEventListener('focus', this._handleFocusEvent);\n    this._textareaElement.removeEventListener('blur', this._handleFocusEvent);\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n\n  /**\n   * Cache the height of a single-row textarea if it has not already been cached.\n   *\n   * We need to know how large a single \"row\" of a textarea is in order to apply minRows and\n   * maxRows. For the initial version, we will assume that the height of a single line in the\n   * textarea does not ever change.\n   */\n  private _cacheTextareaLineHeight(): void {\n    if (this._cachedLineHeight) {\n      return;\n    }\n\n    // Use a clone element because we have to override some styles.\n    let textareaClone = this._textareaElement.cloneNode(false) as HTMLTextAreaElement;\n    textareaClone.rows = 1;\n\n    // Use `position: absolute` so that this doesn't cause a browser layout and use\n    // `visibility: hidden` so that nothing is rendered. Clear any other styles that\n    // would affect the height.\n    textareaClone.style.position = 'absolute';\n    textareaClone.style.visibility = 'hidden';\n    textareaClone.style.border = 'none';\n    textareaClone.style.padding = '0';\n    textareaClone.style.height = '';\n    textareaClone.style.minHeight = '';\n    textareaClone.style.maxHeight = '';\n\n    // In Firefox it happens that textarea elements are always bigger than the specified amount\n    // of rows. This is because Firefox tries to add extra space for the horizontal scrollbar.\n    // As a workaround that removes the extra space for the scrollbar, we can just set overflow\n    // to hidden. This ensures that there is no invalid calculation of the line height.\n    // See Firefox bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=33654\n    textareaClone.style.overflow = 'hidden';\n\n    this._textareaElement.parentNode!.appendChild(textareaClone);\n    this._cachedLineHeight = textareaClone.clientHeight;\n    textareaClone.remove();\n\n    // Min and max heights have to be re-calculated if the cached line height changes\n    this._setMinHeight();\n    this._setMaxHeight();\n  }\n\n  private _measureScrollHeight(): number {\n    const element = this._textareaElement;\n    const previousMargin = element.style.marginBottom || '';\n    const isFirefox = this._platform.FIREFOX;\n    const needsMarginFiller = isFirefox && this._hasFocus;\n    const measuringClass = isFirefox\n      ? 'cdk-textarea-autosize-measuring-firefox'\n      : 'cdk-textarea-autosize-measuring';\n\n    // In some cases the page might move around while we're measuring the `textarea` on Firefox. We\n    // work around it by assigning a temporary margin with the same height as the `textarea` so that\n    // it occupies the same amount of space. See #23233.\n    if (needsMarginFiller) {\n      element.style.marginBottom = `${element.clientHeight}px`;\n    }\n\n    // Reset the textarea height to auto in order to shrink back to its default size.\n    // Also temporarily force overflow:hidden, so scroll bars do not interfere with calculations.\n    element.classList.add(measuringClass);\n    // The measuring class includes a 2px padding to workaround an issue with Chrome,\n    // so we account for that extra space here by subtracting 4 (2px top + 2px bottom).\n    const scrollHeight = element.scrollHeight - 4;\n    element.classList.remove(measuringClass);\n\n    if (needsMarginFiller) {\n      element.style.marginBottom = previousMargin;\n    }\n\n    return scrollHeight;\n  }\n\n  private _cacheTextareaPlaceholderHeight(): void {\n    if (!this._isViewInited || this._cachedPlaceholderHeight != undefined) {\n      return;\n    }\n    if (!this.placeholder) {\n      this._cachedPlaceholderHeight = 0;\n      return;\n    }\n\n    const value = this._textareaElement.value;\n\n    this._textareaElement.value = this._textareaElement.placeholder;\n    this._cachedPlaceholderHeight = this._measureScrollHeight();\n    this._textareaElement.value = value;\n  }\n\n  /** Handles `focus` and `blur` events. */\n  private _handleFocusEvent = (event: FocusEvent) => {\n    this._hasFocus = event.type === 'focus';\n  };\n\n  ngDoCheck() {\n    if (this._platform.isBrowser) {\n      this.resizeToFitContent();\n    }\n  }\n\n  /**\n   * Resize the textarea to fit its content.\n   * @param force Whether to force a height recalculation. By default the height will be\n   *    recalculated only if the value changed since the last call.\n   */\n  resizeToFitContent(force: boolean = false) {\n    // If autosizing is disabled, just skip everything else\n    if (!this._enabled) {\n      return;\n    }\n\n    this._cacheTextareaLineHeight();\n    this._cacheTextareaPlaceholderHeight();\n\n    // If we haven't determined the line-height yet, we know we're still hidden and there's no point\n    // in checking the height of the textarea.\n    if (!this._cachedLineHeight) {\n      return;\n    }\n\n    const textarea = this._elementRef.nativeElement as HTMLTextAreaElement;\n    const value = textarea.value;\n\n    // Only resize if the value or minRows have changed since these calculations can be expensive.\n    if (!force && this._minRows === this._previousMinRows && value === this._previousValue) {\n      return;\n    }\n\n    const scrollHeight = this._measureScrollHeight();\n    const height = Math.max(scrollHeight, this._cachedPlaceholderHeight || 0);\n\n    // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.\n    textarea.style.height = `${height}px`;\n\n    this._ngZone.runOutsideAngular(() => {\n      if (typeof requestAnimationFrame !== 'undefined') {\n        requestAnimationFrame(() => this._scrollToCaretPosition(textarea));\n      } else {\n        setTimeout(() => this._scrollToCaretPosition(textarea));\n      }\n    });\n\n    this._previousValue = value;\n    this._previousMinRows = this._minRows;\n  }\n\n  /**\n   * Resets the textarea to its original size\n   */\n  reset() {\n    // Do not try to change the textarea, if the initialHeight has not been determined yet\n    // This might potentially remove styles when reset() is called before ngAfterViewInit\n    if (this._initialHeight !== undefined) {\n      this._textareaElement.style.height = this._initialHeight;\n    }\n  }\n\n  _noopInputHandler() {\n    // no-op handler that ensures we're running change detection on input events.\n  }\n\n  /** Access injected document if available or fallback to global document reference */\n  private _getDocument(): Document {\n    return this._document || document;\n  }\n\n  /** Use defaultView of injected document if available or fallback to global window reference */\n  private _getWindow(): Window {\n    const doc = this._getDocument();\n    return doc.defaultView || window;\n  }\n\n  /**\n   * Scrolls a textarea to the caret position. On Firefox resizing the textarea will\n   * prevent it from scrolling to the caret position. We need to re-set the selection\n   * in order for it to scroll to the proper position.\n   */\n  private _scrollToCaretPosition(textarea: HTMLTextAreaElement) {\n    const {selectionStart, selectionEnd} = textarea;\n\n    // IE will throw an \"Unspecified error\" if we try to set the selection range after the\n    // element has been removed from the DOM. Assert that the directive hasn't been destroyed\n    // between the time we requested the animation frame and when it was executed.\n    // Also note that we have to assert that the textarea is focused before we set the\n    // selection range. Setting the selection range on a non-focused textarea will cause\n    // it to receive focus on IE and Edge.\n    if (!this._destroyed.isStopped && this._hasFocus) {\n      textarea.setSelectionRange(selectionStart, selectionEnd);\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {CdkAutofill} from './autofill';\nimport {CdkTextareaAutosize} from './autosize';\n\n@NgModule({\n  declarations: [CdkAutofill, CdkTextareaAutosize],\n  exports: [CdkAutofill, CdkTextareaAutosize],\n})\nexport class TextFieldModule {}\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** @docs-private */\nexport function getMatInputUnsupportedTypeError(type: string): Error {\n  return Error(`Input type \"${type}\" isn't supported by matInput.`);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '@angular/core';\n\n/**\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\n * value to them.\n */\nexport const MAT_INPUT_VALUE_ACCESSOR = new InjectionToken<{value: any}>(\n  'MAT_INPUT_VALUE_ACCESSOR',\n);\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BooleanInput, coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {getSupportedInputTypes, Platform} from '@angular/cdk/platform';\nimport {AutofillMonitor} from '@angular/cdk/text-field';\nimport {\n  AfterViewInit,\n  Directive,\n  DoCheck,\n  ElementRef,\n  Inject,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  Optional,\n  Self,\n} from '@angular/core';\nimport {FormGroupDirective, NgControl, NgForm, Validators} from '@angular/forms';\nimport {CanUpdateErrorState, ErrorStateMatcher, mixinErrorState} from '@angular/material/core';\nimport {MatFormFieldControl, MatFormField, MAT_FORM_FIELD} from '@angular/material/form-field';\nimport {Subject} from 'rxjs';\nimport {getMatInputUnsupportedTypeError} from './input-errors';\nimport {MAT_INPUT_VALUE_ACCESSOR} from './input-value-accessor';\n\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\nconst MAT_INPUT_INVALID_TYPES = [\n  'button',\n  'checkbox',\n  'file',\n  'hidden',\n  'image',\n  'radio',\n  'range',\n  'reset',\n  'submit',\n];\n\nlet nextUniqueId = 0;\n\n// Boilerplate for applying mixins to MatInput.\n/** @docs-private */\nconst _MatInputBase = mixinErrorState(\n  class {\n    /**\n     * Emits whenever the component state changes and should cause the parent\n     * form field to update. Implemented as part of `MatFormFieldControl`.\n     * @docs-private\n     */\n    readonly stateChanges = new Subject<void>();\n\n    constructor(\n      public _defaultErrorStateMatcher: ErrorStateMatcher,\n      public _parentForm: NgForm,\n      public _parentFormGroup: FormGroupDirective,\n      /**\n       * Form control bound to the component.\n       * Implemented as part of `MatFormFieldControl`.\n       * @docs-private\n       */\n      public ngControl: NgControl,\n    ) {}\n  },\n);\n\n@Directive({\n  selector: `input[matInput], textarea[matInput], select[matNativeControl],\n      input[matNativeControl], textarea[matNativeControl]`,\n  exportAs: 'matInput',\n  host: {\n    'class': 'mat-mdc-input-element',\n    // The BaseMatInput parent class adds `mat-input-element`, `mat-form-field-control` and\n    // `mat-form-field-autofill-control` to the CSS class list, but this should not be added for\n    // this MDC equivalent input.\n    '[class.mat-input-server]': '_isServer',\n    '[class.mat-mdc-form-field-textarea-control]': '_isInFormField && _isTextarea',\n    '[class.mat-mdc-form-field-input-control]': '_isInFormField',\n    '[class.mdc-text-field__input]': '_isInFormField',\n    '[class.mat-mdc-native-select-inline]': '_isInlineSelect()',\n    // Native input properties that are overwritten by Angular inputs need to be synced with\n    // the native input element. Otherwise property bindings for those don't work.\n    '[id]': 'id',\n    '[disabled]': 'disabled',\n    '[required]': 'required',\n    '[attr.name]': 'name || null',\n    '[attr.readonly]': 'readonly && !_isNativeSelect || null',\n    // Only mark the input as invalid for assistive technology if it has a value since the\n    // state usually overlaps with `aria-required` when the input is empty and can be redundant.\n    '[attr.aria-invalid]': '(empty && required) ? null : errorState',\n    '[attr.aria-required]': 'required',\n    // Native input properties that are overwritten by Angular inputs need to be synced with\n    // the native input element. Otherwise property bindings for those don't work.\n    '[attr.id]': 'id',\n    '(focus)': '_focusChanged(true)',\n    '(blur)': '_focusChanged(false)',\n    '(input)': '_onInput()',\n  },\n  providers: [{provide: MatFormFieldControl, useExisting: MatInput}],\n})\nexport class MatInput\n  extends _MatInputBase\n  implements\n    MatFormFieldControl<any>,\n    OnChanges,\n    OnDestroy,\n    AfterViewInit,\n    DoCheck,\n    CanUpdateErrorState\n{\n  protected _uid = `mat-input-${nextUniqueId++}`;\n  protected _previousNativeValue: any;\n  private _inputValueAccessor: {value: any};\n  private _previousPlaceholder: string | null;\n\n  /** Whether the component is being rendered on the server. */\n  readonly _isServer: boolean;\n\n  /** Whether the component is a native html select. */\n  readonly _isNativeSelect: boolean;\n\n  /** Whether the component is a textarea. */\n  readonly _isTextarea: boolean;\n\n  /** Whether the input is inside of a form field. */\n  readonly _isInFormField: boolean;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  focused: boolean = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  override readonly stateChanges: Subject<void> = new Subject<void>();\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  controlType: string = 'mat-input';\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  autofilled = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get disabled(): boolean {\n    return this._disabled;\n  }\n  set disabled(value: BooleanInput) {\n    this._disabled = coerceBooleanProperty(value);\n\n    // Browsers may not fire the blur event if the input is disabled too quickly.\n    // Reset from here to ensure that the element doesn't become stuck.\n    if (this.focused) {\n      this.focused = false;\n      this.stateChanges.next();\n    }\n  }\n  protected _disabled = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get id(): string {\n    return this._id;\n  }\n  set id(value: string) {\n    this._id = value || this._uid;\n  }\n  protected _id: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input() placeholder: string;\n\n  /**\n   * Name of the input.\n   * @docs-private\n   */\n  @Input() name: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get required(): boolean {\n    return this._required ?? this.ngControl?.control?.hasValidator(Validators.required) ?? false;\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n  }\n  protected _required: boolean | undefined;\n\n  /** Input type of the element. */\n  @Input()\n  get type(): string {\n    return this._type;\n  }\n  set type(value: string) {\n    this._type = value || 'text';\n    this._validateType();\n\n    // When using Angular inputs, developers are no longer able to set the properties on the native\n    // input element. To ensure that bindings for `type` work, we need to sync the setter\n    // with the native property. Textarea elements don't support the type property or attribute.\n    if (!this._isTextarea && getSupportedInputTypes().has(this._type)) {\n      (this._elementRef.nativeElement as HTMLInputElement).type = this._type;\n    }\n  }\n  protected _type = 'text';\n\n  /** An object used to control when error messages are shown. */\n  @Input() override errorStateMatcher: ErrorStateMatcher;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input('aria-describedby') userAriaDescribedBy: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get value(): string {\n    return this._inputValueAccessor.value;\n  }\n  set value(value: any) {\n    if (value !== this.value) {\n      this._inputValueAccessor.value = value;\n      this.stateChanges.next();\n    }\n  }\n\n  /** Whether the element is readonly. */\n  @Input()\n  get readonly(): boolean {\n    return this._readonly;\n  }\n  set readonly(value: BooleanInput) {\n    this._readonly = coerceBooleanProperty(value);\n  }\n  private _readonly = false;\n\n  protected _neverEmptyInputTypes = [\n    'date',\n    'datetime',\n    'datetime-local',\n    'month',\n    'time',\n    'week',\n  ].filter(t => getSupportedInputTypes().has(t));\n\n  constructor(\n    protected _elementRef: ElementRef<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>,\n    protected _platform: Platform,\n    @Optional() @Self() ngControl: NgControl,\n    @Optional() _parentForm: NgForm,\n    @Optional() _parentFormGroup: FormGroupDirective,\n    _defaultErrorStateMatcher: ErrorStateMatcher,\n    @Optional() @Self() @Inject(MAT_INPUT_VALUE_ACCESSOR) inputValueAccessor: any,\n    private _autofillMonitor: AutofillMonitor,\n    ngZone: NgZone,\n    // TODO: Remove this once the legacy appearance has been removed. We only need\n    // to inject the form field for determining whether the placeholder has been promoted.\n    @Optional() @Inject(MAT_FORM_FIELD) protected _formField?: MatFormField,\n  ) {\n    super(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n\n    const element = this._elementRef.nativeElement;\n    const nodeName = element.nodeName.toLowerCase();\n\n    // If no input value accessor was explicitly specified, use the element as the input value\n    // accessor.\n    this._inputValueAccessor = inputValueAccessor || element;\n\n    this._previousNativeValue = this.value;\n\n    // Force setter to be called in case id was not specified.\n    this.id = this.id;\n\n    // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n    // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n    // exists on iOS, we only bother to install the listener on iOS.\n    if (_platform.IOS) {\n      ngZone.runOutsideAngular(() => {\n        _elementRef.nativeElement.addEventListener('keyup', this._iOSKeyupListener);\n      });\n    }\n\n    this._isServer = !this._platform.isBrowser;\n    this._isNativeSelect = nodeName === 'select';\n    this._isTextarea = nodeName === 'textarea';\n    this._isInFormField = !!_formField;\n\n    if (this._isNativeSelect) {\n      this.controlType = (element as HTMLSelectElement).multiple\n        ? 'mat-native-select-multiple'\n        : 'mat-native-select';\n    }\n  }\n\n  ngAfterViewInit() {\n    if (this._platform.isBrowser) {\n      this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(event => {\n        this.autofilled = event.isAutofilled;\n        this.stateChanges.next();\n      });\n    }\n  }\n\n  ngOnChanges() {\n    this.stateChanges.next();\n  }\n\n  ngOnDestroy() {\n    this.stateChanges.complete();\n\n    if (this._platform.isBrowser) {\n      this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n    }\n\n    if (this._platform.IOS) {\n      this._elementRef.nativeElement.removeEventListener('keyup', this._iOSKeyupListener);\n    }\n  }\n\n  ngDoCheck() {\n    if (this.ngControl) {\n      // We need to re-evaluate this on every change detection cycle, because there are some\n      // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n      // that whatever logic is in here has to be super lean or we risk destroying the performance.\n      this.updateErrorState();\n\n      // Since the input isn't a `ControlValueAccessor`, we don't have a good way of knowing when\n      // the disabled state has changed. We can't use the `ngControl.statusChanges`, because it\n      // won't fire if the input is disabled with `emitEvents = false`, despite the input becoming\n      // disabled.\n      if (this.ngControl.disabled !== null && this.ngControl.disabled !== this.disabled) {\n        this.disabled = this.ngControl.disabled;\n        this.stateChanges.next();\n      }\n    }\n\n    // We need to dirty-check the native element's value, because there are some cases where\n    // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n    // updating the value using `emitEvent: false`).\n    this._dirtyCheckNativeValue();\n\n    // We need to dirty-check and set the placeholder attribute ourselves, because whether it's\n    // present or not depends on a query which is prone to \"changed after checked\" errors.\n    this._dirtyCheckPlaceholder();\n  }\n\n  /** Focuses the input. */\n  focus(options?: FocusOptions): void {\n    this._elementRef.nativeElement.focus(options);\n  }\n\n  /** Callback for the cases where the focused state of the input changes. */\n  _focusChanged(isFocused: boolean) {\n    if (isFocused !== this.focused) {\n      this.focused = isFocused;\n      this.stateChanges.next();\n    }\n  }\n\n  _onInput() {\n    // This is a noop function and is used to let Angular know whenever the value changes.\n    // Angular will run a new change detection each time the `input` event has been dispatched.\n    // It's necessary that Angular recognizes the value change, because when floatingLabel\n    // is set to false and Angular forms aren't used, the placeholder won't recognize the\n    // value changes and will not disappear.\n    // Listening to the input event wouldn't be necessary when the input is using the\n    // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n  }\n\n  /** Does some manual dirty checking on the native input `value` property. */\n  protected _dirtyCheckNativeValue() {\n    const newValue = this._elementRef.nativeElement.value;\n\n    if (this._previousNativeValue !== newValue) {\n      this._previousNativeValue = newValue;\n      this.stateChanges.next();\n    }\n  }\n\n  /** Does some manual dirty checking on the native input `placeholder` attribute. */\n  private _dirtyCheckPlaceholder() {\n    const placeholder = this._getPlaceholder();\n    if (placeholder !== this._previousPlaceholder) {\n      const element = this._elementRef.nativeElement;\n      this._previousPlaceholder = placeholder;\n      placeholder\n        ? element.setAttribute('placeholder', placeholder)\n        : element.removeAttribute('placeholder');\n    }\n  }\n\n  /** Gets the current placeholder of the form field. */\n  protected _getPlaceholder(): string | null {\n    return this.placeholder || null;\n  }\n\n  /** Make sure the input is a supported type. */\n  protected _validateType() {\n    if (\n      MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1 &&\n      (typeof ngDevMode === 'undefined' || ngDevMode)\n    ) {\n      throw getMatInputUnsupportedTypeError(this._type);\n    }\n  }\n\n  /** Checks whether the input type is one of the types that are never empty. */\n  protected _isNeverEmpty() {\n    return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n  }\n\n  /** Checks whether the input is invalid based on the native validation. */\n  protected _isBadInput() {\n    // The `validity` property won't be present on platform-server.\n    let validity = (this._elementRef.nativeElement as HTMLInputElement).validity;\n    return validity && validity.badInput;\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get empty(): boolean {\n    return (\n      !this._isNeverEmpty() &&\n      !this._elementRef.nativeElement.value &&\n      !this._isBadInput() &&\n      !this.autofilled\n    );\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get shouldLabelFloat(): boolean {\n    if (this._isNativeSelect) {\n      // For a single-selection `<select>`, the label should float when the selected option has\n      // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\n      // overlapping the label with the options.\n      const selectElement = this._elementRef.nativeElement as HTMLSelectElement;\n      const firstOption: HTMLOptionElement | undefined = selectElement.options[0];\n\n      // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\n      // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\n      return (\n        this.focused ||\n        selectElement.multiple ||\n        !this.empty ||\n        !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label)\n      );\n    } else {\n      return this.focused || !this.empty;\n    }\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  setDescribedByIds(ids: string[]) {\n    if (ids.length) {\n      this._elementRef.nativeElement.setAttribute('aria-describedby', ids.join(' '));\n    } else {\n      this._elementRef.nativeElement.removeAttribute('aria-describedby');\n    }\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  onContainerClick() {\n    // Do not re-focus the input element if the element is already focused. Otherwise it can happen\n    // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\n    // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\n    if (!this.focused) {\n      this.focus();\n    }\n  }\n\n  /** Whether the form control is a native select that is displayed inline. */\n  _isInlineSelect(): boolean {\n    const element = this._elementRef.nativeElement as HTMLSelectElement;\n    return this._isNativeSelect && (element.multiple || element.size > 1);\n  }\n\n  private _iOSKeyupListener = (event: Event): void => {\n    const el = event.target as HTMLInputElement;\n\n    // Note: We specifically check for 0, rather than `!el.selectionStart`, because the two\n    // indicate different things. If the value is 0, it means that the caret is at the start\n    // of the input, whereas a value of `null` means that the input doesn't support\n    // manipulating the selection range. Inputs that don't support setting the selection range\n    // will throw an error so we want to avoid calling `setSelectionRange` on them. See:\n    // https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n    if (!el.value && el.selectionStart === 0 && el.selectionEnd === 0) {\n      // Note: Just setting `0, 0` doesn't fix the issue. Setting\n      // `1, 1` fixes it for the first time that you type text and\n      // then hold delete. Toggling to `1, 1` and then back to\n      // `0, 0` seems to completely fix it.\n      el.setSelectionRange(1, 1);\n      el.setSelectionRange(0, 0);\n    }\n  };\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TextFieldModule} from '@angular/cdk/text-field';\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule} from '@angular/material/core';\nimport {MatFormFieldModule} from '@angular/material/form-field';\nimport {MatInput} from './input';\n\n@NgModule({\n  imports: [MatCommonModule, MatFormFieldModule],\n  exports: [MatInput, MatFormFieldModule, TextFieldModule, MatCommonModule],\n  declarations: [MatInput],\n})\nexport class MatInputModule {}\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],
  "mappings": "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",
  "names": ["listenerOptions", "normalizePassiveListenerOptions", "passive", "AutofillMonitor", "constructor", "_platform", "_ngZone", "_monitoredElements", "Map", "monitor", "elementOrRef", "isBrowser", "EMPTY", "element", "coerceElement", "info", "get", "subject", "result", "Subject", "cssClass", "listener", "event", "animationName", "classList", "contains", "add", "run", "next", "target", "isAutofilled", "remove", "runOutsideAngular", "addEventListener", "set", "unlisten", "removeEventListener", "stopMonitoring", "complete", "delete", "ngOnDestroy", "forEach", "_info", "Platform", "NgZone", "prov", "factory", "fac", "providedIn", "Injectable", "CdkAutofill", "_elementRef", "_autofillMonitor", "cdkAutofill", "EventEmitter", "ngOnInit", "subscribe", "emit", "ElementRef", "selectors", "outputs", "Directive", "args", "selector", "Output", "CdkTextareaAutosize", "minRows", "_minRows", "value", "coerceNumberProperty", "_setMinHeight", "maxRows", "_maxRows", "_setMaxHeight", "enabled", "_enabled", "resizeToFitContent", "reset", "placeholder", "_textareaElement", "_cachedPlaceholderHeight", "undefined", "setAttribute", "removeAttribute", "_cacheTextareaPlaceholderHeight", "document", "_destroyed", "_previousMinRows", "_isViewInited", "_handleFocusEvent", "_hasFocus", "type", "_document", "nativeElement", "minHeight", "_cachedLineHeight", "style", "maxHeight", "ngAfterViewInit", "_initialHeight", "height", "window", "_getWindow", "fromEvent", "pipe", "auditTime", "takeUntil", "_cacheTextareaLineHeight", "textareaClone", "cloneNode", "rows", "position", "visibility", "border", "padding", "overflow", "parentNode", "appendChild", "clientHeight", "_measureScrollHeight", "previousMargin", "marginBottom", "isFirefox", "FIREFOX", "needsMarginFiller", "measuringClass", "scrollHeight", "ngDoCheck", "force", "textarea", "_previousValue", "Math", "max", "requestAnimationFrame", "_scrollToCaretPosition", "setTimeout", "_noopInputHandler", "_getDocument", "doc", "defaultView", "selectionStart", "selectionEnd", "isStopped", "setSelectionRange", "CdkTextareaAutosize_Factory", "t", "DOCUMENT", "dir", "hostAttrs", "hostBindings", "CdkTextareaAutosize_HostBindings", "rf", "ctx", "inputs", "booleanAttribute", "exportAs", "features", "host", "Optional", "Inject", "Input", "alias", "transform", "TextFieldModule", "mod", "declarations", "exports", "NgModule", "getMatInputUnsupportedTypeError", "type", "Error", "MAT_INPUT_VALUE_ACCESSOR", "InjectionToken", "MAT_INPUT_INVALID_TYPES", "nextUniqueId", "_MatInputBase", "mixinErrorState", "constructor", "_defaultErrorStateMatcher", "_parentForm", "_parentFormGroup", "ngControl", "stateChanges", "Subject", "MatInput", "disabled", "_disabled", "value", "coerceBooleanProperty", "focused", "next", "id", "_id", "_uid", "required", "_required", "control", "hasValidator", "Validators", "_type", "_validateType", "_isTextarea", "getSupportedInputTypes", "has", "_elementRef", "nativeElement", "_inputValueAccessor", "readonly", "_readonly", "_platform", "inputValueAccessor", "_autofillMonitor", "ngZone", "_formField", "controlType", "autofilled", "_neverEmptyInputTypes", "filter", "t", "_iOSKeyupListener", "event", "el", "target", "selectionStart", "selectionEnd", "setSelectionRange", "element", "nodeName", "toLowerCase", "_previousNativeValue", "IOS", "runOutsideAngular", "addEventListener", "_isServer", "isBrowser", "_isNativeSelect", "_isInFormField", "multiple", "ngAfterViewInit", "monitor", "subscribe", "isAutofilled", "ngOnChanges", "ngOnDestroy", "complete", "stopMonitoring", "removeEventListener", "ngDoCheck", "updateErrorState", "_dirtyCheckNativeValue", "_dirtyCheckPlaceholder", "focus", "options", "_focusChanged", "isFocused", "_onInput", "newValue", "placeholder", "_getPlaceholder", "_previousPlaceholder", "setAttribute", "removeAttribute", "indexOf", "ngDevMode", "_isNeverEmpty", "_isBadInput", "validity", "badInput", "empty", "shouldLabelFloat", "selectElement", "firstOption", "selectedIndex", "label", "setDescribedByIds", "ids", "length", "join", "onContainerClick", "_isInlineSelect", "size", "ElementRef", "Platform", "NgControl", "NgForm", "FormGroupDirective", "ErrorStateMatcher", "AutofillMonitor", "NgZone", "MAT_FORM_FIELD", "selectors", "hostAttrs", "hostVars", "hostBindings", "MatInput_HostBindings", "rf", "ctx", "MatInput_blur_HostBindingHandler", "MatInput_input_HostBindingHandler", "provide", "MatFormFieldControl", "useExisting", "Directive", "args", "selector", "exportAs", "host", "providers", "Optional", "Self", "Inject", "Input", "name", "errorStateMatcher", "userAriaDescribedBy", "MatInputModule", "mod", "declarations", "imports", "MatCommonModule", "MatFormFieldModule", "exports", "TextFieldModule", "NgModule"]
}
